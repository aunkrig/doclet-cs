
/*
 * de.unkrig.doclet.cs - A doclet which generates metadata documents for a CheckStyle extension
 *
 * Copyright (c) 2014, Arno Unkrig
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of conditions and the
 *       following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *       following disclaimer in the documentation and/or other materials provided with the distribution.
 *    3. The name of the author may not be used to endorse or promote products derived from this software without
 *       specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package de.unkrig.doclet.cs;

import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.sf.eclipsecs.core.config.meta.IOptionProvider;

import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.Doc;
import com.sun.javadoc.DocErrorReporter;
import com.sun.javadoc.MethodDoc;
import com.sun.javadoc.Tag;

import de.unkrig.commons.nullanalysis.Nullable;

/**
 * Generates <a href="http://www.mediawiki.org/wiki/Help:Formatting">MediaWiki markup</a> from JAVADOC.
 */
public final
class MediawikiGenerator {

    private MediawikiGenerator() {}

    private static final Pattern
    PRE_BLOCK = Pattern.compile("\\s*<pre>\\s*(.*?)\\s*</pre>", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);

    private static final Pattern
    BEGINNING_OF_LINE = Pattern.compile("^", Pattern.MULTILINE);

    /**
     * Generates a MediaWiki markup document files in {@code todir} for the given {@code classDoc}.
     *
     * @throws Longjump The {@code classDoc} was not processed
     */
    public static void
    generate(final ClassDoc classDoc, PrintWriter pw, final DocErrorReporter errorReporter) throws Longjump {

        final String ruleName  = MediawikiGenerator.optionalTag(classDoc, "@cs-rule-name", errorReporter);
        if (ruleName == null) {
            errorReporter.printError(classDoc.position(), "Doc tag '@cs-rule-name' missing");
            throw new Longjump();
        }

        pw.println("<!-- This file was generated by the CS doclet; see http://cs-contrib.unkrig.de -->");

        String ruleDesc = DocletUtil.commentText(classDoc);
        if (ruleDesc == null) {
            errorReporter.printError(classDoc.position(), "Rule lacks a description");
            throw new Longjump();
        }

        ruleDesc = DocletUtil.javadocTextToHtml(ruleDesc, classDoc.position(), errorReporter);

        ruleDesc = MediawikiGenerator.htmlToMediawikiMarkup(ruleDesc);

        pw.println(ruleDesc);
        pw.println();

        MediawikiGenerator.printProperties(classDoc.methods(), pw, errorReporter);

        if (classDoc.tags("@cs-quickfix-classname").length > 0) {
            pw.println("<p>");
            pw.println("  Quickfixes are available for this check.");
            pw.println("</p>");
        }
    }

    private static void
    printProperties(final MethodDoc[] methodDocs, PrintWriter pw, final DocErrorReporter errorReporter)
    throws Longjump {

        boolean firstProperty = true;
        for (MethodDoc methodDoc : methodDocs) {

            // SUPPRESS CHECKSTYLE LineLength:7
            final String name                 = MediawikiGenerator.optionalTag(methodDoc, "@cs-property-name",                   errorReporter);
            String       datatype             = MediawikiGenerator.optionalTag(methodDoc, "@cs-property-datatype",               errorReporter);
            final String defaultValue         = MediawikiGenerator.optionalTag(methodDoc, "@cs-property-default-value",          errorReporter);
            final String overrideDefaultValue = MediawikiGenerator.optionalTag(methodDoc, "@cs-property-override-default-value", errorReporter);
            final String optionProvider       = MediawikiGenerator.optionalTag(methodDoc, "@cs-property-option-provider",        errorReporter);
            final Tag[]  valueOptions         = methodDoc.tags("@cs-property-value-option");

            if (
                name == null
                && datatype == null
                && defaultValue == null
                && overrideDefaultValue == null
            ) continue;

            if (firstProperty) {
                firstProperty = false;
                pw.println("== Properties ==");
                pw.println();
                pw.println("Default values appear <u>underlined</u>.");
                pw.println();
            }

            // Get the 'property description'. This is a bit complicated because the methods
            // 'comment text' and and the '@cs-property-desc' doc tag must both be taken into
            // account.
            // We also check whether there is HTML markup in the description, because ECLIPSE-CS
            // does not support that.
            String description = DocletUtil.commentText(methodDoc);
            if (description == null) {

                description = DocletUtil.optionalTag(methodDoc, "@cs-property-desc", errorReporter);
                if (description == null) {
                    errorReporter.printError(methodDoc.position(), (
                        "Method has neither a comment text nor a '@cs-property-text' tag; "
                        + "at least one of them must exist"
                    ));
                    continue;
                }
            }

            // Some consistency checks.
            String methodName = methodDoc.name();
            if (!methodName.startsWith("set")) {
                errorReporter.printError(methodDoc.position(), "Method is not a setter");
                continue;
            }
            if (!methodName.substring(3).equalsIgnoreCase(name)) {
                errorReporter.printError(
                    methodDoc.position(),
                    "Property name does not match method name"
                );
                continue;
            }
            if (methodDoc.parameters().length != 1) {
                errorReporter.printError(methodDoc.position(), "Setter must have exactly one parameter");
                continue;
            }

            String nav;

            // For possible 'datatype's see "http://eclipse-cs.sourceforge.net/dtds/checkstyle-metadata_1_1.dtd"
            if (datatype != null) datatype = datatype.intern();
            if (datatype == "Boolean") { // SUPPRESS CHECKSTYLE StringLiteralEquality
                nav = (
                    name
                    + " = \""
                    + MediawikiGenerator.catValues(new String[] { "true", "false" }, defaultValue, " | ")
                    + "\""
                );
            } else
            if (datatype == "SingleSelect") { // SUPPRESS CHECKSTYLE StringLiteralEquality
                String[] values = MediawikiGenerator.valueOptions(
                    methodDoc,
                    optionProvider,
                    valueOptions,
                    errorReporter
                );
                nav = name + " = \"" + MediawikiGenerator.catValues(values, defaultValue, " | ") + "\"";
            } else
            if (datatype == "MultiCheck") { // SUPPRESS CHECKSTYLE StringLiteralEquality
                String[] values = MediawikiGenerator.valueOptions(
                    methodDoc,
                    optionProvider,
                    valueOptions,
                    errorReporter
                );
                String[] defaultValues = defaultValue == null ? new String[0] : defaultValue.split(",");
                nav = name + " = \"" + MediawikiGenerator.catValues(values, defaultValues, ", ") + "\"";
            } else
            if (datatype == "Regex") { // SUPPRESS CHECKSTYLE StringLiteralEquality
                nav = (
                    name
                    + " = \"''[http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum "
                    + datatype
                    + "]''\""
                );
                if (defaultValue != null) {
                    nav += " (optional; default value is " + defaultValue + ")";
                }
            } else
            {
                nav = name + " = \"<i>" + datatype + "</i>\"";
                if (defaultValue != null) {
                    nav += " (optional; default value is " + defaultValue + ")";
                }
            }

            String intertitle = DocletUtil.optionalTag(methodDoc, "@cs-intertitle", errorReporter);
            if (intertitle != null) {
                intertitle = DocletUtil.javadocTextToHtml(intertitle, methodDoc.position(), errorReporter);
                intertitle = MediawikiGenerator.htmlToMediawikiMarkup(intertitle);
                pw.printf("%1$s%n%n", intertitle);
            }

            description = DocletUtil.javadocTextToHtml(description, methodDoc.position(), errorReporter);
            description = MediawikiGenerator.htmlToMediawikiMarkup(description);
            pw.printf((
                ""
                + "<dl>%n"
                + "<dt>%1$s%n" // Must not close with '</dt>'
                + "<dd>%2$s%n" // Must not close with '</dd>'
                + "</dl>%n"
                + "%n"
            ), nav, description);

//            if (optionProvider != null) {
//                pw.printf("                <enumeration option-provider=\"%s\"/>%n", optionProvider);
//            }
//            if (valueOptions.length > 0) {
//                pw.printf("                <enumeration>%n");
//                for (Tag valueOption : valueOptions) {
//                    pw.printf(
//                        "                    <property-value-option value=\"%s\"/>%n",
//                        valueOption.text()
//                    );
//                }
//                pw.printf("                </enumeration>%n");
//            }
//            pw.printf("            </property-metadata>%n");
        }
    }

    /** @return The value option for the given setter method */
    private static String[]
    valueOptions(
        MethodDoc              methodDoc,
        @Nullable String       optionProvider,
        Tag[]                  valueOptions,
        final DocErrorReporter errorReporter
    ) throws Longjump {

        String[] values;
        if (optionProvider == null) {
            values = new String[valueOptions.length];
            for (int i = 0; i < valueOptions.length; i++) {
                values[i] = valueOptions[i].text();
            }
        } else
        if (valueOptions.length > 0) {
            errorReporter.printError(
                methodDoc.position(),
                (
                    "@cs-property-option-provider and @cs-property-value-option are mutually "
                    + "exclusive"
                )
            );
            throw new Longjump();
        } else
        {
            Class<?> c;
            try {
                c = CsDoclet.class.getClassLoader().loadClass(optionProvider);
            } catch (Exception e) {
                errorReporter.printError(
                    methodDoc.position(),
                    "Loading option provider '" + optionProvider + "': " + e.getMessage()
                );
                throw new Longjump(); // SUPPRESS CHECKSTYLE AvoidHidingCause
            }

            if (c.getSuperclass() == Enum.class) {
                Object[] tmp;
                try {
                    tmp = (Object[]) c.getDeclaredMethod("values").invoke(null);
                } catch (Exception e) {
                    errorReporter.printError(methodDoc.position(), e.getMessage());
                    throw new Longjump(); // SUPPRESS CHECKSTYLE AvoidHidingCause
                }
                values = new String[tmp.length];
                for (int i = 0; i < tmp.length; i++) {
                    values[i] = ((Enum<?>) tmp[i]).name().toLowerCase();
                }
            } else
            if (IOptionProvider.class.isAssignableFrom(c)) {
                List<?> tmp;
                try {
                    tmp = (List<?>) c.getDeclaredMethod("getOptions").invoke(c.newInstance());
                } catch (Exception e) {
                    errorReporter.printError(methodDoc.position(), e.getMessage());
                    throw new Longjump(); // SUPPRESS CHECKSTYLE AvoidHidingCause
                }
                values = tmp.toArray(new String[0]);
            } else
            {
                errorReporter.printError(methodDoc.position(), (
                    ""
                    + "Option provider class '"
                    + optionProvider
                    + "' must either extend 'Enum' or implement 'IOptionProvider'"
                ));
                throw new Longjump();
            }
        }
        return values;
    }

    /**
     * Concatenate the given {@code values}, separated with {@code glue}, and underline the value which equals the
     * {@code defaultValue}.
     */
    private static String
    catValues(String[] values, @Nullable String defaultValue, String glue) {

        return MediawikiGenerator.catValues(
            values,
            defaultValue == null ? new String[0] : new String[] { defaultValue }, glue
        );
    }

    /**
     * Concatenate the given {@code values}, separated with {@code glue}, and underline the values which are also
     * contained in {@code defaultValue}.
     */
    private static String
    catValues(String[] values, String[] defaultValues, String glue) {
        assert values.length >= 1;

        StringBuilder sb  = new StringBuilder();
        Set<String>   dvs = new HashSet<String>();
        dvs.addAll(Arrays.asList(defaultValues));
        for (int i = 0;;) {
            String value = values[i];
            if (dvs.contains(value)) {
                sb.append("<u>" + value + "</u>");
            } else {
                sb.append(value);
            }
            if (++i == values.length) break;
            sb.append(glue);
        }
        return sb.toString();
    }

    @Nullable private static String
    optionalTag(Doc doc, String tagName, DocErrorReporter errorReporter) throws Longjump {
        Tag[] tags = doc.tags(tagName);
        if (tags.length == 0) return null;
        if (tags.length > 1) {
            errorReporter.printError(doc.position(), "'" + tagName + "' must appear at most once");
            throw new Longjump();
        }
        return tags[0].text();
    }

    /**
     * Indicates that an operation has completed abnormally, but this condition has already been handled, e.g. by
     * displaying an error message. Code that catches the {@link Longjump} should <i>not</i> print, process or log
     * it; instead, it should 'continue with the next element' or take a similar action. Consequently, has neither
     * a {@code message} nor a {@code cause}.
     */
    public static
    class Longjump extends Throwable {

        private static final long  serialVersionUID = 1L;

        /**
         * Override {@link Throwable#fillInStackTrace()} with a NOP operation; this throwing and catching fast as
         * lightning.
         */
        @Override public Throwable
        fillInStackTrace() { return this; }

        @Override public String
        getMessage() { throw new UnsupportedOperationException("getMessage"); }

        @Override public String
        getLocalizedMessage() { throw new UnsupportedOperationException("getLocalizedMessage"); }

        @Override public Throwable
        getCause() { throw new UnsupportedOperationException("getCause"); }

        @Override public Throwable
        initCause(@Nullable Throwable cause) { throw new UnsupportedOperationException("initCause"); }

        @Override public String
        toString() { return "Longjump"; }

        @Override public void
        printStackTrace(@Nullable PrintStream s) { throw new UnsupportedOperationException("printStackTrace"); }

        @Override public void
        printStackTrace(@Nullable PrintWriter s) { throw new UnsupportedOperationException("printStackTrace"); }

        @Override public StackTraceElement[]
        getStackTrace() { throw new UnsupportedOperationException("getStackTrace"); }
    }

    /**
     * Converts an HTML document into <a href="http://www.mediawiki.org/wiki/Help:Formatting">MediaWiki markup</a>.
     */
    public static String
    htmlToMediawikiMarkup(String s) {

        // Must transform PRE blocks into MW 'preformatted text'. MW <i>does</i> handle PRE blocks,
        // but it SGML-escapes all entities within it.
        PRE_BLOCKS: {
            Matcher m = MediawikiGenerator.PRE_BLOCK.matcher(s);

            if (!m.find()) break PRE_BLOCKS;

            StringBuffer sb = new StringBuffer();
            do {
                String replacement = (
                    DocletUtil.LINE_SEPARATOR
                    + MediawikiGenerator.BEGINNING_OF_LINE.matcher(m.group(1)).replaceAll(" ")
                    + DocletUtil.LINE_SEPARATOR
                );
                m.appendReplacement(sb, replacement);
            } while (m.find());
            s = m.appendTail(sb).toString();
        }

        return s;
    }
}
